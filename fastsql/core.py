# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Database', 'DBTable']

# %% ../nbs/00_core.ipynb 5
from dataclasses import dataclass,is_dataclass,asdict,MISSING
import sqlalchemy as sa
from sqlalchemy.orm import Session
from fastcore.utils import *

# %% ../nbs/00_core.ipynb 8
_type_map = {int: sa.Integer, str: sa.String, bool: sa.Boolean}
def _column(name, typ, primary=False):
    return sa.Column(name, _type_map[typ], primary_key=primary)

# %% ../nbs/00_core.ipynb 9
class Database:
    "A connection to a SQLAlchemy database"
    def __init__(self, conn_str):
        self.conn_str = conn_str
        self.engine = sa.create_engine(conn_str)
        self.meta = sa.MetaData()

    def __repr__(self): return f"Database({self.conn_str})"
    
    @property
    def conn(self): return self.engine.connect()

# %% ../nbs/00_core.ipynb 11
class DBTable:
    "A connection to a SQLAlchemy table, created if needed"
    def __init__(self, table: sa.Table, database: Database, cls):
        self.table,self.db,self.cls = table,database,cls
        table.create(self.db.engine, checkfirst=True)

    def __repr__(self) -> str: return self.table.name
    
    @property
    def conn(self): return self.db.conn

# %% ../nbs/00_core.ipynb 12
@patch
def create(self:Database, cls, pk:str|None=None):
    "Get a table object, creating in DB if needed"
    cols = {k:v for k,v in cls.__dataclass_fields__.items()}
    columns = [] if pk is None else [_column(pk, cols.pop(pk).type, primary=True)]
    columns += [_column(k, v.type) for k,v in cols.items()]
    tbl = sa.Table(cls.__name__, self.meta, *columns)
    return DBTable(tbl, self, cls)

# %% ../nbs/00_core.ipynb 14
@patch
def print_schema(self:Database):
    "Show all tables and columns"
    inspector = sa.inspect(self.engine)
    for table_name in inspector.get_table_names():
        print(f"Table: {table_name}")
        pk_cols = inspector.get_pk_constraint(table_name)['constrained_columns']
        for column in inspector.get_columns(table_name):
            pk_marker = '*' if column['name'] in pk_cols else ''
            print(f"  - {pk_marker}{column['name']}: {column['type']}")

# %% ../nbs/00_core.ipynb 16
@patch
def exists(self:DBTable):
    "Check if this table exists in the DB"
    return sa.inspect(self.db.engine).has_table(self.table.name)

# %% ../nbs/00_core.ipynb 19
def _wanted(obj): return {k:v for k,v in asdict(obj).items() if v not in (None,MISSING)}

# %% ../nbs/00_core.ipynb 20
@patch
def insert(self:DBTable, obj):
    "Insert an object into this table, and return it"
    with self.conn as conn:
        result = conn.execute(sa.insert(self.table).values(**_wanted(obj)).returning(*self.table.columns))
        row = result.one()  # Consume the result set
        conn.commit()
        return self.cls(**row._asdict())

# %% ../nbs/00_core.ipynb 23
@patch
def __call__(self:DBTable, where:str|None=None, where_args:Iterable|dict|None=None,
             order_by:str|None=None, limit:int|None=None, offset:int|None=None, **kw):
    "Query this table"
    query = sa.select(self.table)
    if where_args: kw = {**kw, **where_args}
    if kw: query = query.where(sa.text(where).bindparams(**kw))
    if order_by: query = query.order_by(sa.text(order_by))
    if limit is not None: query = query.limit(limit)
    if offset is not None: query = query.offset(offset)
    with self.conn as conn:
        rows = conn.execute(query).all()
        return [self.cls(**row._asdict()) for row in rows]

# %% ../nbs/00_core.ipynb 27
@patch
def _pk_where(self:DBTable, meth,key):
    if not isinstance(key,tuple): key = (key,)
    pkv = zip(self.table.primary_key.columns, key)
    cond = sa.and_(*[col==val for col,val in pkv])
    return getattr(self.table,meth)().where(cond)

# %% ../nbs/00_core.ipynb 28
@patch
def __getitem__(self:DBTable, key):
    "Get item with PK `key`"
    with self.conn as conn:
        qry = self._pk_where('select', key)
        result = conn.execute(qry).first()
    return self.cls(**result._asdict()) if result else None

# %% ../nbs/00_core.ipynb 30
@patch
def update(self:DBTable, obj):
    d = _wanted(obj)
    pks = tuple(d[k.name] for k in self.table.primary_key)
    with self.conn as conn:
        qry = self._pk_where('update', pks).values(**d).returning(*self.table.columns)
        result = conn.execute(qry)
        row = result.one()
        conn.commit()
        return self.cls(**row._asdict())

# %% ../nbs/00_core.ipynb 32
@patch
def delete(self:DBTable, key):
    "Delete item with PK `key` and return count deleted"
    with self.conn as conn:
        result = conn.execute(self._pk_where('delete', key))
        conn.commit()
        return result.rowcount
